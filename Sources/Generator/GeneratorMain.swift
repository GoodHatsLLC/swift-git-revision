import Foundation

#if canImport(Darwin)
  import Darwin
#elseif canImport(Glibc)
  import Glibc
#elseif canImport(ucrt)
  import ucrt
#endif

@main
enum GeneratorMain {
  static func main() {
    let usage = "Usage: Generator <repository-path> <output-json-path> <output-swift-path>"
    let arguments = Array(CommandLine.arguments.dropFirst())

    if arguments.contains("-h") || arguments.contains("--help") {
      print(usage)
      exit(0)
    }

    guard arguments.count == 3 else {
      writeStderr("error: \(usage)\n")
      exit(64)
    }

    let repositoryPath = arguments[0]
    let outputPath = arguments[1]
    let swiftOutputPath = arguments[2]

    do {
      let repositoryURL = URL(fileURLWithPath: repositoryPath)
      let outputURL = URL(fileURLWithPath: outputPath)
      let swiftOutputURL = URL(fileURLWithPath: swiftOutputPath)
      let collector = InfoCollector(repositoryURL: repositoryURL)
      let info = try collector.collect()
      try writeJSON(info, to: outputURL)
      try writeSwiftSource(to: swiftOutputURL)
    } catch {
      let message = (error as? LocalizedError)?.errorDescription ?? error.localizedDescription
      writeStderr("\(message)\n")
      exit(1)
    }
  }
}

private func writeJSON(_ info: GitRevInfo, to outputURL: URL) throws {
  let outputDirectory = outputURL.deletingLastPathComponent()
  try FileManager.default.createDirectory(
    at: outputDirectory,
    withIntermediateDirectories: true,
    attributes: nil
  )

  let encoder = JSONEncoder()
  encoder.dateEncodingStrategy = .iso8601
  encoder.outputFormatting = [.sortedKeys, .prettyPrinted]
  let data = try encoder.encode(info)
  try data.write(to: outputURL, options: .atomic)
}

private func writeSwiftSource(to outputURL: URL) throws {
  let outputDirectory = outputURL.deletingLastPathComponent()
  try FileManager.default.createDirectory(
    at: outputDirectory,
    withIntermediateDirectories: true,
    attributes: nil
  )

  let source = #"""
// Generated by swift-git-revision. Do not edit.
import Foundation

/// Git revision metadata captured at build time.
public struct GitRevInfo: Codable, Sendable {
  /// Details for the most recent commit.
  public let lastCommit: Commit
  /// Current branch name, or nil for detached HEAD.
  public let branch: String?

  /// Full commit hash for the most recent commit.
  public var hash: String {
    lastCommit.hash
  }

  /// Short commit hash for the most recent commit.
  public var shortHash: String {
    lastCommit.shortHash
  }

  /// Cached revision info, if it could be loaded.
  private static let cached: GitRevInfo? = {
    do { return try loadFromBundle() } catch { return nil }
  }()

  /// Loads revision info from the target bundle, rethrowing load errors.
  public static var current: GitRevInfo {
    get throws {
      if let cached { return cached }
      return try loadFromBundle()
    }
  }

  /// Creates revision info with a commit and branch.
  public init(lastCommit: Commit, branch: String?) {
    self.lastCommit = lastCommit
    self.branch = branch
  }
}

extension GitRevInfo {
  /// Metadata for a Git commit.
  public struct Commit: Codable, Sendable {
    /// Commit author identity.
    public let author: User
    /// Committer identity.
    public let committer: User
    /// Commit subject, if available.
    public let subject: String?
    /// Author timestamp.
    public let authorDate: Date
    /// Committer timestamp.
    public let commitDate: Date
    /// Short commit hash.
    public let shortHash: String
    /// Full commit hash.
    public let hash: String

    /// Creates commit metadata.
    public init(
      author: User,
      committer: User,
      subject: String?,
      authorDate: Date,
      commitDate: Date,
      shortHash: String,
      hash: String
    ) {
      self.author = author
      self.committer = committer
      self.subject = subject
      self.authorDate = authorDate
      self.commitDate = commitDate
      self.shortHash = shortHash
      self.hash = hash
    }
  }

  /// A Git user identity.
  public struct User: Codable, Sendable, CustomStringConvertible {
    /// User name.
    public let name: String
    /// User email.
    public let email: String

    /// Creates a user identity.
    public init(name: String, email: String) {
      self.name = name
      self.email = email
    }

    /// Returns the formatted identity as "Name <email>".
    public var description: String {
      "\(name) <\(email)>"
    }
  }

  /// Errors thrown when loading revision info.
  public enum LoadError: Error, LocalizedError, Sendable {
    /// The JSON resource could not be found in the bundle.
    case resourceNotFound(resource: String, bundle: String)

    /// A human-readable description of the error.
    public var errorDescription: String? {
      switch self {
      case .resourceNotFound(let resource, let bundle):
        return "resource '\(resource)' not found in \(bundle)"
      }
    }
  }
}

private extension GitRevInfo {
  static func loadFromBundle() throws -> GitRevInfo {
    let resourceName = "git-revision-info"
    let resourceExtension = "json"
    let fullName = "\(resourceName).\(resourceExtension)"
    let bundle = resourceBundle()
    guard let url = bundle.url(forResource: resourceName, withExtension: resourceExtension) else {
      let bundleName = bundle.bundleIdentifier ?? "unknown bundle"
      throw LoadError.resourceNotFound(resource: fullName, bundle: bundleName)
    }

    let data = try Data(contentsOf: url)
    let decoder = JSONDecoder()
    decoder.dateDecodingStrategy = .iso8601
    return try decoder.decode(GitRevInfo.self, from: data)
  }

  static func resourceBundle() -> Bundle {
#if SWIFT_PACKAGE
    return Bundle.module
#else
    return Bundle(for: GitRevInfoBundleToken.self)
#endif
  }
}

private final class GitRevInfoBundleToken {}
"""#

  let data = Data(source.utf8)
  try data.write(to: outputURL, options: .atomic)
}

private func writeStderr(_ message: String) {
  guard let data = message.data(using: .utf8) else { return }
  FileHandle.standardError.write(data)
}
